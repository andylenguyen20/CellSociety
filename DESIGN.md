DESIGN.md (due when the analysis is submitted)

PROVIDES THE HIGH_LEVEL DESIGN GOALS OF YOUR PROJECT
The goal of this project is design a flexible model that allows users to create and run simulations of specific types that follow certain rules. It also allows users to style their simulations given different configurations and provide additional functionality beyond that of a simple simulation.


EXPLAINS IN DETAIL HOW TO ADD NEW FEATURES TO YOUR PROJECT

To add a new feature to the project depends on what type of feature you're trying to add. In order to add a new simulation, you would need to create a simulation.xml file, as well as add in a specific cell and grid subclass that implements a set of rules specific to the simulation. For instance, the WatorCell and WatorGrid classes supply implementation of the Cell rules and Grid functionality that makes the Wator simulation unique from other simulations. You would also need to edit the configuration component of this project, which configures the simulation with a specific set of cells and its corresponding Grid. For instance, the CellFactory class generates a cell of a specific type. This type would need to be added to the CellFactory's implementation of the method used to generate cells. In regards to adding new features for visualization, it is most likely necessary to edit the Visualization class directly, since this class handles several user actions and most of the visuals of the simulation.

JUSTIFIES MAJOR DESIGN CHOICES, INCLUDING TRADE-OFFS (I.E. PROS AND CONS), MADE IN YOUR PROJECT

One major design choice we decided to use was to have the Cell class extend Polygon, which meant that cells are drawn based off of their vertices rather than based off of their position in a two-dimensional array. By doing this, there was a huge tradeoff in the fact that we had to spend lots of time altering the way we configured the cells, draw the cells, as well as create a set of coordinate systems for the cells to live in. The pros of this design was that using vertices to map out the cells made neighbor-finding much more universal and made drawing actually easier; this was because finding neighbors via vertice intersection was simple and applies for all cell shapes and because drawing is now based off of a "scaling" factor based off the generated coordinate system of the grid type.

Another major design choice was to offer plenty of public functionality in regards to the Cell class. While it may seem odd from a back-end perspective that a Cell has several public methods (such as getColors, getParams, setParams, setCurrentState), we felt it was necessary because these methods were used across packages by the Visualization component. This is because the Visualization component needed to be able to change cell states from user input. While there was a tradeoff in encapsulation, it allowed us to implement additional functionality within the Visualizer. We also felt that this made Cell more likely to stay closed, in that it supplied information that may be useful with other features.

The last major design choice that I will talk about is the decision to have so many static factory classes: GridFactory, CellFactory, XMLWriterFactory, MapFactory, and several factory classes within visualization component. We felt that while object-oriented thinking was a necessary stepping stone into the simulation implementation (i.e. using grid and cell as abstractions with several subclasses), we felt that the configuration and visualization component required more one-time actions that didn't really differ based off the environment around it. For instance, there was no need to have a MenuCreator object that runs once during the entire program at the beginning. Instead, it made more sense to have a static class that performs actions that aren't affected by attributes that this class contains or any of the environment around it. A MenuCreator will always create a menu the same way given some specification information, so why not make it a factory class? The same goes for the other classes. The tradeoff was that while we let go of some object-oriented thinking (in the sense that an object doesn't always contain another object but instead uses a factory class to perform a given action), it was positive in the sense that it was more clear to the reader that these actions are static and don't vary regardless of the environment around it.

STATES ANY ASSUMPTIONS OR DECISIONS MADE TO SIMPLIFY OR RESOLVE AMBIGUITIES IN YOUR PROJECT'S FUNCTIONALITY